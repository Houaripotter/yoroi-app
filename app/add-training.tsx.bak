import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Platform,
  Image,
} from 'react-native';
import { useCustomPopup } from '@/components/CustomPopup';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { LinearGradient } from 'expo-linear-gradient';
import DateTimePicker from '@react-native-community/datetimepicker';
import {
  X,
  Calendar as CalendarIcon,
  Clock,
  ChevronDown,
  Dumbbell,
  Check,
  Home,
  Plus,
  Star,
} from 'lucide-react-native';
import { ScreenWrapper } from '@/components/ScreenWrapper';
import { Header } from '@/components/ui/Header';
import { Card } from '@/components/ui/Card';
import { useTheme } from '@/lib/ThemeContext';
import { useBadges } from '@/lib/BadgeContext';
import { addTraining, getClubs, Club, Exercise } from '@/lib/database';
import { SPORTS, MUSCLES, getSportIcon, getSportName, getClubLogoSource } from '@/lib/sports';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { Dimensions } from 'react-native';

// Constants for non-theme values
const { width: SCREEN_WIDTH } = Dimensions.get('window');
const IS_SMALL_SCREEN = SCREEN_WIDTH < 375;
const RADIUS = { sm: 8, md: 12 };
const SPACING = { sm: 8, md: 12, lg: IS_SMALL_SCREEN ? 12 : 16, xl: IS_SMALL_SCREEN ? 16 : 20 }; // Adaptive spacing
const FONT_SIZE = { xs: 12, sm: 13, md: 14, lg: 16, xl: 18, xxl: 20, display: 28 };
import { successHaptic, errorHaptic } from '@/lib/haptics';
import { backupReminderService } from '@/lib/backupReminderService';
import { playSuccessSound } from '@/lib/soundManager';
import { incrementReviewTrigger, askForReview } from '@/lib/reviewService';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { ExercisePickerModal } from '@/components/ExercisePickerModal';
import logger from '@/lib/security/logger';
import HealthConnect from '@/lib/healthConnect.ios';

// ============================================
// NOUVEL ENTRAINEMENT
// ============================================

export default function AddTrainingScreen() {
  const { colors, gradients, isDark } = useTheme();
  const router = useRouter();
  const { checkBadges } = useBadges();
  const { showPopup, PopupComponent } = useCustomPopup();
  const params = useLocalSearchParams<{ date?: string }>();
  const [clubs, setClubs] = useState<Club[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Form state
  const [selectedSport, setSelectedSport] = useState('jjb');
  const [selectedClub, setSelectedClub] = useState<Club | null>(null);
  const [date, setDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [startTime, setStartTime] = useState(() => {
    const now = new Date();
    now.setMinutes(0, 0, 0);
    return now;
  });
  const [showTimePicker, setShowTimePicker] = useState(false);
  const [duration, setDuration] = useState(60);
  const [notes, setNotes] = useState('');
  const [selectedMuscles, setSelectedMuscles] = useState<string[]>([]);
  const [exercises, setExercises] = useState<Exercise[]>([]);
  const [showExerciseModal, setShowExerciseModal] = useState(false);
  const [techniqueRating, setTechniqueRating] = useState<number | null>(null);

  // Calculer heure de fin
  const calculateEndTime = (): string => {
    const end = new Date(startTime.getTime() + duration * 60 * 1000);
    return end.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
  };

  // Parse date from params if provided
  useEffect(() => {
    if (params.date) {
      const parsedDate = new Date(params.date + 'T12:00:00');
      if (!isNaN(parsedDate.getTime())) {
        setDate(parsedDate);
      }
    }
  }, [params.date]);

  useEffect(() => {
    loadClubs();
  }, []);

  const loadClubs = async () => {
    try {
      const data = await getClubs();
      setClubs(data);
    } catch (error) {
      logger.error('Erreur chargement clubs:', error);
    }
  };

  const handleDateChange = (event: any, selectedDate?: Date) => {
    setShowDatePicker(Platform.OS === 'ios');
    if (selectedDate) {
      setDate(selectedDate);
    }
  };

  const toggleMuscle = (muscleId: string) => {
    setSelectedMuscles(prev =>
      prev.includes(muscleId)
        ? prev.filter(m => m !== muscleId)
        : [...prev, muscleId]
    );
  };

  const handleSave = async () => {
    setIsSubmitting(true);

    try {
      await addTraining({
        club_id: selectedClub?.id,
        sport: selectedSport,
        date: format(date, 'yyyy-MM-dd'),
        duration_minutes: duration || undefined,
        start_time: startTime.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }),
        notes: notes || undefined,
        muscles: selectedMuscles.length > 0 ? selectedMuscles.join(',') : undefined,
        exercises: exercises.length > 0 ? exercises : undefined,
        technique_rating: techniqueRating,
      });

      successHaptic();
      playSuccessSound();

      // ðŸ”„ SYNC VERS APPLE HEALTH
      try {
        const startDateTime = new Date(date);
        const [hours, minutes] = startTime.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }).split(':');
        startDateTime.setHours(parseInt(hours), parseInt(minutes), 0);

        const endDateTime = new Date(startDateTime.getTime() + (duration || 60) * 60 * 1000);

        const exported = await HealthConnect.writeWorkout({
          activityType: getSportName(selectedSport),
          startDate: startDateTime,
          endDate: endDateTime,
        });

        if (exported) {
          logger.info('âœ… EntraÃ®nement synchronisÃ© vers Apple Health:', selectedSport);
        }
      } catch (healthError) {
        // Ne pas bloquer la sauvegarde si l'export Ã©choue
        logger.warn('âš ï¸ Export Apple Health Ã©chouÃ© (non bloquant):', healthError);
      }

      // Trigger review aprÃ¨s une action positive
      await incrementReviewTrigger();
      await askForReview();

      // Verifier les badges debloques
      await checkBadges();

      // VÃ©rifier si on doit afficher le rappel de sauvegarde
      const shouldShowBackupReminder = await backupReminderService.onDataAdded();

      if (shouldShowBackupReminder) {
        // Afficher le rappel de sauvegarde avec option de backup
        await backupReminderService.showReminder(() => {
          // Rediriger vers le menu Plus (export disponible)
          router.push('/(tabs)/more');
        });
        router.back();
      } else {
        showPopup(
          'Entrainement ajoute',
          `${getSportName(selectedSport)} enregistre !`,
          [{ text: 'OK', style: 'primary', onPress: () => router.back() }]
        );
      }
    } catch (error) {
      logger.error('Erreur sauvegarde:', error);
      errorHaptic();
      showPopup('Erreur', "Impossible d'enregistrer l'entrainement");
    } finally {
      setIsSubmitting(false);
    }
  };

  // Clubs filtrÃ©s par sport sÃ©lectionnÃ©
  const filteredClubs = clubs.filter(c => c.sport === selectedSport);

  // Afficher les muscles et exercices si musculation ou street workout
  const showMuscles = selectedSport === 'musculation' || selectedSport === 'street_workout';

  return (
    <ScreenWrapper noPadding>
      <Header title="Nouvel Entrainement" showClose />
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >

        {/* MES CLUBS - EN PREMIER */}
        {clubs.length > 0 && (
          <>
            <Text style={[styles.sectionTitle, { color: colors.textSecondary }]}>Clubs & Coach</Text>
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.clubsScroll}
              contentContainerStyle={styles.clubsScrollContent}
            >
              <TouchableOpacity
                style={[
                  styles.clubCard,
                  { backgroundColor: colors.card, borderColor: colors.border },
                  !selectedClub && { borderColor: colors.gold, backgroundColor: colors.goldMuted },
                ]}
                onPress={() => setSelectedClub(null)}
              >
                <View style={[styles.clubCardIcon, { backgroundColor: colors.cardHover }]}>
                  <Home size={24} color={!selectedClub ? colors.gold : colors.textSecondary} strokeWidth={2} />
                </View>
                <Text style={[styles.clubCardName, { color: !selectedClub ? colors.gold : colors.textSecondary }]}>
                  Libre
                </Text>
              </TouchableOpacity>
              {clubs.map((club) => (
                <TouchableOpacity
                  key={club.id}
                  style={[
                    styles.clubCard,
                    {
                      backgroundColor: selectedClub?.id === club.id ? colors.goldMuted : colors.card,
                      borderColor: selectedClub?.id === club.id ? colors.gold : 'transparent',
                      borderWidth: selectedClub?.id === club.id ? 2 : 0,
                    },
                  ]}
                  onPress={() => {
                    setSelectedClub(club);
                    // Auto-sÃ©lectionner le sport du club si diffÃ©rent
                    if (club.sport && club.sport !== selectedSport) {
                      setSelectedSport(club.sport);
                    }
                  }}
                >
                  {(() => {
                    const logoSource = club.logo_uri ? getClubLogoSource(club.logo_uri) : null;
                    if (logoSource) {
                      return (
                        <Image
                          source={logoSource}
                          style={styles.clubCardLogo}
                          resizeMode="cover"
                        />
                      );
                    }
                    return (
                      <View style={[styles.clubCardIcon, { backgroundColor: club.color || colors.cardHover }]}>
                        <MaterialCommunityIcons
                          name={getSportIcon(club.sport || 'autre') as any}
                          size={24}
                          color="#FFFFFF"
                        />
                      </View>
                    );
                  })()}
                  <Text
                    style={[
                      styles.clubCardName,
                      { color: selectedClub?.id === club.id ? colors.gold : colors.textPrimary },
                    ]}
                    numberOfLines={1}
                  >
                    {club.name}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </>
        )}

        {/* SPORT */}
        <Text style={[styles.sectionTitle, { color: colors.textSecondary }]}>Sport</Text>

        {/* Group sports by category */}
        {(() => {
          const categoryLabels: Record<string, string> = {
            combat_striking: 'Combat (Pieds-Poings)',
            combat_grappling: 'Combat (Grappling)',
            fitness: 'Musculation',
            cardio: 'Cardio',
            collectif: 'Sports Collectifs',
            raquettes: 'Raquettes',
            autre: 'Autres',
          };

          const categories = ['combat_grappling', 'combat_striking', 'fitness', 'cardio', 'collectif', 'raquettes', 'autre'];

          return categories.map((category) => {
            const sportsInCategory = SPORTS.filter(s => s.category === category);
            if (sportsInCategory.length === 0) return null;

            return (
              <View key={category} style={styles.categorySection}>
                <Text style={[styles.categoryLabel, { color: colors.textMuted }]}>
                  {categoryLabels[category]}
                </Text>
                <ScrollView
                  horizontal
                  showsHorizontalScrollIndicator={false}
                  contentContainerStyle={styles.sportsContainer}
                >
                  {sportsInCategory.map((sport) => {
                    const isSelected = selectedSport === sport.id;

                    return (
                      <TouchableOpacity
                        key={sport.id}
                        style={[
                          styles.sportItem,
                          { backgroundColor: colors.card, borderColor: 'transparent', borderWidth: 0 },
                          isSelected && {
                            borderColor: colors.gold,
                            backgroundColor: colors.goldMuted,
                            borderWidth: 2,
                          },
                        ]}
                        onPress={() => {
                          setSelectedSport(sport.id);
                          if (selectedClub && selectedClub.sport !== sport.id) {
                            setSelectedClub(null);
                          }
                        }}
                      >
                        <View style={styles.sportIconContainer}>
                          <MaterialCommunityIcons
                            name={sport.icon as any}
                            size={24}
                            color={isSelected ? colors.gold : sport.color}
                          />
                          {isSelected && (
                            <View style={[styles.checkmarkBadge, { backgroundColor: colors.gold }]}>
                              <Check size={12} color="#FFFFFF" strokeWidth={3} />
                            </View>
                          )}
                        </View>
                        <Text
                          style={[
                            styles.sportName,
                            { color: colors.textSecondary },
                            isSelected && { color: colors.gold, fontWeight: '700' },
                          ]}
                        >
                          {sport.name}
                        </Text>
                      </TouchableOpacity>
                    );
                  })}
                </ScrollView>
              </View>
            );
          });
        })()}

        {/* DATE */}
        <Text style={[styles.sectionTitle, { color: colors.textSecondary }]}>Date</Text>
        <TouchableOpacity
          style={[styles.dateSelector, { backgroundColor: colors.card, borderColor: colors.border }]}
          onPress={() => setShowDatePicker(true)}
        >
          <CalendarIcon size={20} color={colors.gold} />
          <Text style={[styles.dateText, { color: colors.textPrimary }]}>
            {format(date, 'EEEE d MMMM yyyy', { locale: fr })}
          </Text>
          <ChevronDown size={20} color={colors.textSecondary} />
        </TouchableOpacity>

        {showDatePicker && (
          <View style={{ backgroundColor: colors.backgroundCard, borderRadius: 12, padding: 8 }}>
            <DateTimePicker
              value={date}
              mode="date"
              display={Platform.OS === 'ios' ? 'spinner' : 'default'}
              themeVariant={isDark ? 'dark' : 'light'}
              textColor={colors.textPrimary}
              onChange={handleDateChange}
              maximumDate={new Date()}
              locale="fr"
            />
          </View>
        )}

        {/* HEURE DE DÃ‰BUT */}
        <Text style={[styles.sectionTitle, { color: colors.textSecondary }]}>Heure de debut</Text>
        <TouchableOpacity
          style={[styles.timeButton, { backgroundColor: colors.card, borderColor: colors.border }]}
          onPress={() => setShowTimePicker(true)}
        >
          <Clock size={20} color={colors.gold} />
          <Text style={[styles.timeText, { color: colors.textPrimary }]}>
            {startTime.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' })}
          </Text>
        </TouchableOpacity>

        {showTimePicker && (
          <View style={{ backgroundColor: colors.backgroundCard, borderRadius: 12, padding: 8 }}>
            <DateTimePicker
              value={startTime}
              mode="time"
              is24Hour={true}
              display={Platform.OS === 'ios' ? 'spinner' : 'default'}
              themeVariant={isDark ? 'dark' : 'light'}
              textColor={colors.textPrimary}
              onChange={(event, selectedTime) => {
                setShowTimePicker(Platform.OS === 'ios');
                if (selectedTime) setStartTime(selectedTime);
              }}
            />
          </View>
        )}

        {/* DURÃ‰E ESTIMÃ‰E */}
        <Text style={[styles.sectionTitle, { color: colors.textSecondary }]}>Duree estimee</Text>
        <View style={styles.durationContainer}>
          {[30, 45, 60, 90, 120].map((d) => (
            <TouchableOpacity
              key={d}
              style={[
                styles.durationItem,
                { backgroundColor: colors.card, borderColor: colors.border },
                duration === d && { borderColor: colors.gold, backgroundColor: colors.goldMuted },
              ]}
              onPress={() => setDuration(d)}
            >
              <Text
                style={[
                  styles.durationText,
                  { color: colors.textSecondary },
                  duration === d && { color: colors.gold },
                ]}
              >
                {d}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
        <Text style={[styles.endTimeText, { color: colors.textMuted }]}>
          Fin estimee : {calculateEndTime()}
        </Text>

        {/* MUSCLES (si musculation) */}
        {showMuscles && (
          <>
            <Text style={[styles.sectionTitle, { color: colors.textSecondary }]}>Muscles travailles</Text>
            <View style={styles.musclesContainer}>
              {MUSCLES.map((muscle) => (
                <TouchableOpacity
                  key={muscle.id}
                  style={[
                    styles.muscleItem,
                    { backgroundColor: colors.card, borderColor: colors.border },
                    selectedMuscles.includes(muscle.id) && { borderColor: colors.gold, backgroundColor: colors.goldMuted },
                  ]}
                  onPress={() => toggleMuscle(muscle.id)}
                >
                  {selectedMuscles.includes(muscle.id) && (
                    <Check size={14} color={colors.gold} />
                  )}
                  <Text
                    style={[
                      styles.muscleName,
                      { color: colors.textSecondary },
                      selectedMuscles.includes(muscle.id) && { color: colors.gold },
                    ]}
                  >
                    {muscle.name}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </>
        )}

        {/* EXERCICES (si musculation) */}
        {showMuscles && (
          <>
            <View style={styles.exercisesHeader}>
              <Text style={[styles.sectionTitle, { color: colors.textSecondary, marginBottom: 0 }]}>Exercices</Text>
              <TouchableOpacity
                style={[styles.addExerciseButton, { backgroundColor: colors.gold }]}
                onPress={() => setShowExerciseModal(true)}
              >
                <Plus size={16} color="#FFF" strokeWidth={3} />
                <Text style={styles.addExerciseText}>Ajouter</Text>
              </TouchableOpacity>
            </View>

            {exercises.length > 0 && (
              <View style={styles.exercisesList}>
                {exercises.map((exercise, index) => (
                  <View
                    key={index}
                    style={[styles.exerciseItem, { backgroundColor: colors.card, borderColor: colors.border }]}
                  >
                    <View style={styles.exerciseInfo}>
                      <Text style={[styles.exerciseName, { color: colors.textPrimary }]}>
                        {exercise.name}
                      </Text>
                      <Text style={[styles.exerciseDetails, { color: colors.textMuted }]}>
                        {exercise.sets} sÃ©ries Ã— {exercise.reps} reps @ {exercise.weight}kg
                      </Text>
                    </View>
                    <TouchableOpacity
                      onPress={() => setExercises(prev => prev.filter((_, i) => i !== index))}
                      style={styles.removeExerciseButton}
                    >
                      <X size={18} color={colors.textMuted} />
                    </TouchableOpacity>
                  </View>
                ))}
              </View>
            )}
          </>
        )}

        {/* NOTES */}
        <Text style={[styles.sectionTitle, { color: colors.textSecondary }]}>Notes (optionnel)</Text>
        <TextInput
          style={[styles.notesInput, { backgroundColor: colors.card, borderColor: colors.border, color: colors.textPrimary }]}
          value={notes}
          onChangeText={setNotes}
          placeholder="Comment s'est passe l'entrainement ?"
          placeholderTextColor={colors.textMuted}
          multiline
          numberOfLines={3}
        />

        {/* NOTE TECHNIQUE */}
        <View style={[styles.techniqueSection, { backgroundColor: colors.accent + '10', borderColor: colors.accent + '30' }]}>
          <View style={styles.techniqueSectionHeader}>
            <Text style={[styles.techniqueSectionTitle, { color: colors.textPrimary }]}>ðŸŽ¯ Note ta technique</Text>
            <Text style={[styles.techniqueSectionSubtitle, { color: colors.textMuted }]}>
              Comment Ã©tait ta technique aujourd'hui ?
            </Text>
          </View>

          {/* Ã‰toiles */}
          <View style={styles.starsContainer}>
            {[1, 2, 3, 4, 5].map((rating) => (
              <TouchableOpacity
                key={rating}
                onPress={() => setTechniqueRating(rating)}
                style={styles.starButton}
                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
              >
                <Star
                  size={36}
                  color={techniqueRating && rating <= techniqueRating ? colors.accent : colors.textMuted}
                  fill={techniqueRating && rating <= techniqueRating ? colors.accent : 'transparent'}
                  strokeWidth={2}
                />
              </TouchableOpacity>
            ))}
          </View>

          {/* Labels sous les Ã©toiles */}
          <View style={styles.starsLabels}>
            <Text style={[styles.starLabel, { color: colors.textMuted }]}>1</Text>
            <Text style={[styles.starLabel, { color: colors.textMuted }]}>2</Text>
            <Text style={[styles.starLabel, { color: colors.textMuted }]}>3</Text>
            <Text style={[styles.starLabel, { color: colors.textMuted }]}>4</Text>
            <Text style={[styles.starLabel, { color: colors.textMuted }]}>5</Text>
          </View>

          {/* Info scientifique */}
          <View style={styles.techniqueInfo}>
            <Text style={[styles.techniqueInfoText, { color: colors.textMuted }]}>
              ðŸ’¡ "Noter ta technique amÃ©liore ta conscience corporelle et rÃ©duit ton risque de blessure de 35%"
            </Text>
          </View>

          {/* Bouton Passer */}
          {techniqueRating !== null && (
            <TouchableOpacity
              onPress={() => setTechniqueRating(null)}
              style={styles.skipButton}
            >
              <Text style={[styles.skipButtonText, { color: colors.textMuted }]}>âœ• RÃ©initialiser</Text>
            </TouchableOpacity>
          )}
        </View>

        {/* BOUTON SAVE */}
        <TouchableOpacity
          style={[styles.saveButton, isSubmitting && styles.saveButtonDisabled]}
          onPress={handleSave}
          disabled={isSubmitting}
        >
          <LinearGradient
            colors={gradients.gold}
            style={styles.saveButtonGradient}
          >
            <Dumbbell size={22} color={colors.background} />
            <Text style={[styles.saveButtonText, { color: colors.background }]}>
              {isSubmitting ? 'Enregistrement...' : 'Enregistrer'}
            </Text>
          </LinearGradient>
        </TouchableOpacity>

        <View style={{ height: 100 }} />
      </ScrollView>

      {/* Exercise Picker Modal */}
      <ExercisePickerModal
        visible={showExerciseModal}
        onClose={() => setShowExerciseModal(false)}
        onAddExercise={(exercise) => setExercises(prev => [...prev, exercise])}
      />

      <PopupComponent />
    </ScreenWrapper>
  );
}

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
  },
  content: {
    paddingHorizontal: SPACING.xl,
    paddingTop: SPACING.lg,
  },

  // HEADER
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 24,
  },
  closeButton: {
    width: 40,
    height: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: FONT_SIZE.xxl,
    fontWeight: '700',
  },

  // SECTION
  sectionTitle: {
    fontSize: FONT_SIZE.xs,
    fontWeight: '600',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    marginBottom: SPACING.md,
    marginTop: SPACING.sm,
  },

  // SPORTS
  sportsScroll: {
    marginHorizontal: -20,
    marginBottom: SPACING.lg,
  },
  categorySection: {
    marginBottom: SPACING.lg,
  },
  categoryLabel: {
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1,
    marginBottom: 8,
    paddingHorizontal: 20,
    textTransform: 'uppercase',
  },
  sportsContainer: {
    paddingHorizontal: SPACING.xl,
    gap: 10,
  },
  sportItem: {
    alignItems: 'center',
    borderRadius: RADIUS.md,
    paddingVertical: SPACING.md,
    paddingHorizontal: IS_SMALL_SCREEN ? SPACING.md : SPACING.lg, // Moins de padding sur petits Ã©crans
    borderWidth: 1,
    minWidth: 80,
  },
  sportItemActive: {
    // Colors applied inline
  },
  sportIconContainer: {
    position: 'relative',
    marginBottom: 4,
  },
  checkmarkBadge: {
    position: 'absolute',
    top: -4,
    right: -4,
    width: 18,
    height: 18,
    borderRadius: 9,
    alignItems: 'center',
    justifyContent: 'center',
  },
  sportIcon: {
    fontSize: 28,
    marginBottom: 4,
  },
  sportName: {
    fontSize: FONT_SIZE.xs,
    fontWeight: '600',
  },
  sportNameActive: {
    // Colors applied inline
  },

  // CLUBS - Nouveau design horizontal
  clubsScroll: {
    marginHorizontal: -20,
    marginBottom: SPACING.lg,
  },
  clubsScrollContent: {
    paddingHorizontal: SPACING.xl,
    gap: 12,
  },
  clubCard: {
    alignItems: 'center',
    borderRadius: RADIUS.md,
    padding: IS_SMALL_SCREEN ? SPACING.sm : SPACING.md, // Padding adaptatif
    borderWidth: 2,
    minWidth: IS_SMALL_SCREEN ? 80 : 90, // Plus compact sur petits Ã©crans
    maxWidth: 100,
  },
  clubCardIcon: {
    width: 50,
    height: 50,
    borderRadius: 25,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
  },
  clubCardEmoji: {
    fontSize: 24,
  },
  clubCardLogo: {
    width: 50,
    height: 50,
    borderRadius: 25,
    marginBottom: 8,
  },
  clubCardName: {
    fontSize: FONT_SIZE.xs,
    fontWeight: '600',
    textAlign: 'center',
  },

  // Legacy clubs (pour compatibilitÃ©)
  clubsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 10,
    marginBottom: SPACING.lg,
  },
  clubItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    borderRadius: RADIUS.sm,
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderWidth: 1,
  },
  clubDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  clubLogo: {
    width: 24,
    height: 24,
    borderRadius: 12,
  },
  clubItemText: {
    fontSize: FONT_SIZE.md,
    fontWeight: '600',
  },

  // DATE
  dateSelector: {
    flexDirection: 'row',
    alignItems: 'center',
    borderRadius: RADIUS.md,
    padding: SPACING.lg,
    marginBottom: SPACING.lg,
    gap: SPACING.md,
    borderWidth: 1,
  },
  dateText: {
    flex: 1,
    fontSize: FONT_SIZE.lg,
    fontWeight: '600',
    textTransform: 'capitalize',
  },

  // TIME
  timeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    paddingVertical: SPACING.lg,
    paddingHorizontal: SPACING.lg,
    borderRadius: RADIUS.md,
    borderWidth: 1,
    marginBottom: SPACING.lg,
  },
  timeText: {
    fontSize: FONT_SIZE.xl,
    fontWeight: '600',
  },
  endTimeText: {
    fontSize: FONT_SIZE.sm,
    textAlign: 'center',
    marginTop: -SPACING.sm,
    marginBottom: SPACING.lg,
  },

  // DURATION
  durationContainer: {
    flexDirection: 'row',
    gap: 10,
    marginBottom: SPACING.md,
  },
  durationItem: {
    paddingVertical: SPACING.md,
    paddingHorizontal: SPACING.lg,
    borderRadius: RADIUS.sm,
    borderWidth: 1,
  },
  durationItemActive: {
    // Colors applied inline
  },
  durationText: {
    fontSize: FONT_SIZE.md,
    fontWeight: '600',
  },
  durationTextActive: {
    // Colors applied inline
  },
  durationChip: {
    flex: 1,
    paddingVertical: SPACING.md,
    borderRadius: RADIUS.sm,
    alignItems: 'center',
    borderWidth: 1,
  },

  // MUSCLES
  musclesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 10,
    marginBottom: SPACING.lg,
  },
  muscleItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    borderRadius: RADIUS.sm,
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderWidth: 1,
  },
  muscleItemActive: {
    // Colors applied inline
  },
  muscleName: {
    fontSize: FONT_SIZE.sm,
    fontWeight: '600',
  },
  muscleNameActive: {
    // Colors applied inline
  },

  // EXERCISES
  exercisesHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: SPACING.md,
    marginTop: SPACING.sm,
  },
  addExerciseButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: RADIUS.sm,
  },
  addExerciseText: {
    color: '#FFF',
    fontSize: FONT_SIZE.sm,
    fontWeight: '600',
  },
  exercisesList: {
    gap: 10,
    marginBottom: SPACING.lg,
  },
  exerciseItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    borderRadius: RADIUS.md,
    padding: SPACING.md,
    borderWidth: 1,
  },
  exerciseInfo: {
    flex: 1,
  },
  exerciseName: {
    fontSize: FONT_SIZE.md,
    fontWeight: '600',
    marginBottom: 4,
  },
  exerciseDetails: {
    fontSize: FONT_SIZE.xs,
  },
  removeExerciseButton: {
    padding: 4,
  },

  // NOTES
  notesInput: {
    borderRadius: RADIUS.md,
    padding: IS_SMALL_SCREEN ? SPACING.md : SPACING.lg, // Padding adaptatif
    fontSize: IS_SMALL_SCREEN ? 14 : 15, // Plus petit sur petits Ã©crans
    borderWidth: 1,
    marginBottom: 24,
    minHeight: 80,
    textAlignVertical: 'top',
  },

  // TECHNIQUE RATING
  techniqueSection: {
    borderRadius: RADIUS.md,
    padding: SPACING.lg,
    marginBottom: 24,
    borderWidth: 1,
  },
  techniqueSectionHeader: {
    marginBottom: SPACING.md,
    alignItems: 'center',
  },
  techniqueSectionTitle: {
    fontSize: FONT_SIZE.lg,
    fontWeight: '700',
    marginBottom: 4,
  },
  techniqueSectionSubtitle: {
    fontSize: FONT_SIZE.sm,
    fontWeight: '500',
  },
  starsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: IS_SMALL_SCREEN ? 6 : 8, // Moins d'espace entre Ã©toiles sur petits Ã©crans
    marginBottom: 4,
  },
  starButton: {
    padding: 4,
  },
  starsLabels: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 20,
    marginBottom: SPACING.md,
  },
  starLabel: {
    fontSize: FONT_SIZE.xs,
    fontWeight: '700',
  },
  techniqueInfo: {
    marginTop: SPACING.sm,
    paddingTop: SPACING.md,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.05)',
  },
  techniqueInfoText: {
    fontSize: FONT_SIZE.xs,
    fontStyle: 'italic',
    lineHeight: 16,
    textAlign: 'center',
  },
  skipButton: {
    marginTop: SPACING.sm,
    alignItems: 'center',
  },
  skipButtonText: {
    fontSize: FONT_SIZE.sm,
    fontWeight: '600',
  },

  // SAVE
  saveButton: {
    borderRadius: RADIUS.md,
    overflow: 'hidden',
  },
  saveButtonDisabled: {
    opacity: 0.6,
  },
  saveButtonGradient: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 18,
    gap: 10,
  },
  saveButtonText: {
    fontSize: FONT_SIZE.xl,
    fontWeight: '700',
  },
});
